"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7770],{3905:(e,n,a)=>{a.d(n,{Zo:()=>c,kt:()=>h});var t=a(7294);function s(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach((function(n){s(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function r(e,n){if(null==e)return{};var a,t,s=function(e,n){if(null==e)return{};var a,t,s={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||(s[a]=e[a]);return s}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=t.createContext({}),d=function(e){var n=t.useContext(l),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},c=function(e){var n=d(e.components);return t.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var a=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=d(a),h=s,m=u["".concat(l,".").concat(h)]||u[h]||p[h]||i;return a?t.createElement(m,o(o({ref:n},c),{},{components:a})):t.createElement(m,o({ref:n},c))}));function h(e,n){var a=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var i=a.length,o=new Array(i);o[0]=u;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r.mdxType="string"==typeof e?e:s,o[1]=r;for(var d=2;d<i;d++)o[d]=a[d];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}u.displayName="MDXCreateElement"},5350:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var t=a(7462),s=(a(7294),a(3905));const i={sidebar_position:3},o="Open/Closed Principle (OCP)",r={unversionedId:"solid-principles/open_closed_principle",id:"solid-principles/open_closed_principle",title:"Open/Closed Principle (OCP)",description:"What is OCP?",source:"@site/docs/solid-principles/open_closed_principle.md",sourceDirName:"solid-principles",slug:"/solid-principles/open_closed_principle",permalink:"/para_ruby/docs/solid-principles/open_closed_principle",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"The Single Responsibility Principle",permalink:"/para_ruby/docs/solid-principles/single_responsibility_principle"},next:{title:"Liskov Substitution Principle (LSP)",permalink:"/para_ruby/docs/solid-principles/liskov_substitution_principle"}},l={},d=[{value:"What is OCP?",id:"what-is-ocp",level:2},{value:"Code example",id:"code-example",level:3},{value:"Second code example",id:"second-code-example",level:3},{value:"Advanced examples",id:"advanced-examples",level:3},{value:"Tests for Shape classes",id:"tests-for-shape-classes",level:3}],c={toc:d};function p(e){let{components:n,...a}=e;return(0,s.kt)("wrapper",(0,t.Z)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"openclosed-principle-ocp"},"Open/Closed Principle (OCP)"),(0,s.kt)("h2",{id:"what-is-ocp"},"What is OCP?"),(0,s.kt)("p",null,"The Open/Closed Principle (OCP) is a principle of object-oriented design that states that software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. This means that new functionality can be added to existing classes without changing their existing code. This allows for code reusability and maintainability, as well as flexibility to accommodate future changes in requirements. To implement the OCP, developers can use techniques such as ",(0,s.kt)("a",{parentName:"p",href:"/para_ruby/docs/glossary/abstraction"},"abstraction"),", ",(0,s.kt)("a",{parentName:"p",href:"/para_ruby/docs/glossary/polymorphism"},"polymorphism"),", and ",(0,s.kt)("a",{parentName:"p",href:"/para_ruby/docs/glossary/inheritance"},"inheritance"),"."),(0,s.kt)("admonition",{title:"Explain like I'm five.",type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"The Open/Closed Principle is like a box. You can put things inside the box and take things out, but you can't change the box itself. This is good because you can use the same box over and over again and it will still work the same way. And if you want to put a different kind of thing in the box, you can just make a new box that is the same size but has a different shape or color. This way, you can keep using the old box and the new box without having to change anything.")),(0,s.kt)("h3",{id:"code-example"},"Code example"),(0,s.kt)("p",null,"One code example of the Open/Closed Principle (OCP) is a payment gateway class that uses the strategy pattern to process different types of payment methods:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'class PaymentGateway\n  def initialize(payment_method)\n    @payment_method = payment_method\n  end\n\n  def process(amount)\n    @payment_method.process(amount)\n  end\nend\n\nclass CreditCardPayment\n  def process(amount)\n    # Code to process credit card payment goes here\n    puts "Processing credit card payment for #{amount}..."\n  end\nend\n\nclass DebitCardPayment\n  def process(amount)\n    # Code to process debit card payment goes here\n    puts "Processing debit card payment for #{amount}..."\n  end\nend\n\nclass PayPalPayment\n  def process(amount)\n    # Code to process PayPal payment goes here\n    puts "Processing PayPal payment for #{amount}..."\n  end\nend\n\n# Example usage\n\npayment_gateway = PaymentGateway.new(CreditCardPayment.new)\npayment_gateway.process(100)\n# Output: Processing credit card payment for 100...\n\npayment_gateway = PaymentGateway.new(DebitCardPayment.new)\npayment_gateway.process(200)\n# Output: Processing debit card payment for 200...\n\npayment_gateway = PaymentGateway.new(PayPalPayment.new)\npayment_gateway.process(300)\n# Output: Processing PayPal payment for 300...\n')),(0,s.kt)("p",null,"In this code example, the PaymentGateway class is open for extension, as it allows developers to easily add support for new payment methods by implementing the appropriate interfaces. However, the PaymentGateway class is closed for modification, as the existing methods and interfaces should not be changed in order to maintain backward compatibility and avoid breaking existing code."),(0,s.kt)("h3",{id:"second-code-example"},"Second code example"),(0,s.kt)("p",null,"Another code example of the OCP is a logging class that uses the decorator pattern to log messages to different types of destinations:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'class Logger\n  def initialize(logger)\n    @logger = logger\n  end\n\n  def log(message)\n    @logger.log(message)\n  end\nend\n\nclass FileLogger\n  def log(message)\n    # Code to log message to file goes here\n    File.open("log.txt", "a") do |file|\n      file.puts(message)\n    end\n  end\nend\n\nclass DatabaseLogger\n  def log(message)\n    # Code to log message to database goes here\n    Log.create(message: message)\n  end\nend\n\nclass MessageQueueLogger\n  def log(message)\n    # Code to log message to message queue goes here\n    MessageQueue.enqueue(message)\n  end\nend\n\n# Example usage\n\nlogger = Logger.new(FileLogger.new)\nlogger.log("This is a message.")\n# Output: Log message added to log.txt\n\nlogger = Logger.new(DatabaseLogger.new)\nlogger.log("This is a message.")\n# Output: Log message added to database\n\nlogger = Logger.new(MessageQueueLogger.new)\nlogger.log("This is a message.")\n# Output: Log message added to message queue\n\n')),(0,s.kt)("h3",{id:"advanced-examples"},"Advanced examples"),(0,s.kt)("p",null,"Here is an advanced code example that demonstrates the Open/Closed Principle (OCP) in Ruby:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'# Define a base Shape class\nclass Shape\n  # Define a method to calculate the area\n  def area\n    raise NotImplementedError, "Method not implemented"\n  end\nend\n\n# Define a Circle class that inherits from Shape\nclass Circle < Shape\n  # Initialize a circle with a radius\n  def initialize(radius)\n    @radius = radius\n  end\n\n  # Override the area method to calculate the area of a circle\n  def area\n    Math::PI * (@radius ** 2)\n  end\nend\n\n# Define a Square class that inherits from Shape\nclass Square < Shape\n  # Initialize a square with a side length\n  def initialize(side)\n    @side = side\n  end\n\n  # Override the area method to calculate the area of a square\n  def area\n    @side ** 2\n  end\nend\n\n# Define a Shapes class that can calculate the total area of a collection of shapes\nclass Shapes\n  # Initialize a shapes collection with an array of shapes\n  def initialize(shapes)\n    @shapes = shapes\n  end\n\n  # Calculate the total area of all shapes in the collection\n  def total_area\n    @shapes.map(&:area).sum\n  end\nend\n\n# Example usage\n\n# Create a circle with radius 2\ncircle = Circle.new(2)\n\n# Create a square with side length 2\nsquare = Square.new(2)\n\n# Create a shapes collection with the circle and square\nshapes = Shapes.new([circle, square])\n\n# Calculate the total area of all shapes in the collection\nputs shapes.total_area\n# Output: 12.566370614359172\n')),(0,s.kt)("h3",{id:"tests-for-shape-classes"},"Tests for Shape classes"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'describe Shape do\n  let(:shape) { Shape.new }\n\n  it "calculates the area" do\n    expect(shape).to respond_to(:area)\n  end\n\n  it "raises a NotImplementedError when the area method is called" do\n    expect{ shape.area }.to raise_error(NotImplementedError, "Method not implemented")\n  end\nend\n\ndescribe Circle do\n  let(:radius) { 2 }\n  let(:circle) { Circle.new(radius) }\n\n  it "initializes with a radius" do\n    expect(circle.instance_variable_get(:@radius)).to eq(radius)\n  end\n\n  it "calculates the area" do\n    expect(circle.area).to eq(Math::PI * (radius ** 2))\n  end\nend\n\ndescribe Square do\n  let(:side) { 2 }\n  let(:square) { Square.new(side) }\n\n  it "initializes with a side length" do\n    expect(square.instance_variable_get(:@side)).to eq(side)\n  end\n\n  it "calculates the area" do\n    expect(square.area).to eq(side ** 2)\n  end\nend\n\ndescribe Shapes do\n  let(:shapes) { Shapes.new([]) }\n\n  it "initializes with an array of shapes" do\n    expect(shapes.instance_variable_get(:@shapes)).to eq([])\n  end\n\n  it "calculates the total area of all shapes in the collection" do\n    circle = Circle.new(2)\n    square = Square.new(2)\n\n    shapes = Shapes.new([circle, square])\n    expect(shapes.total_area).to eq(12.566370614359172)\n  end\nend\n\n')),(0,s.kt)("p",null,"In this code example, the Shape, Circle, and Square classes demonstrate the Open/Closed Principle (OCP) by being open for extension and closed for modification. The Shape class is open for extension, as it allows developers to easily create new shapes by inheriting from the Shape class and implementing the appropriate methods. However, the Shape class is closed for modification, as the existing methods and interfaces should not be changed in order to maintain backward compatibility and avoid breaking existing code. The Shapes class is also open for extension, as it allows developers to easily add support for new shapes by implementing the appropriate interfaces. However, the Shapes class is closed for modification, as the existing methods and interfaces should not be changed in order to maintain backward compatibility and avoid breaking existing code."))}p.isMDXComponent=!0}}]);