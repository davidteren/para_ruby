"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"A Guide to OOP & Design Patterns in Ruby","href":"/para_ruby/docs/intro","docId":"intro"},{"type":"link","label":"What\'s a Paradigm?","href":"/para_ruby/docs/paradigms","docId":"paradigms"},{"type":"category","label":"SOLID Principles","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"What is SOLID","href":"/para_ruby/docs/solid-principles/the_five_principles","docId":"solid-principles/the_five_principles"},{"type":"link","label":"The Single Responsibility Principle","href":"/para_ruby/docs/solid-principles/single_responsibility_principle","docId":"solid-principles/single_responsibility_principle"},{"type":"link","label":"Open/Closed Principle (OCP)","href":"/para_ruby/docs/solid-principles/open_closed_principle","docId":"solid-principles/open_closed_principle"},{"type":"link","label":"Liskov Substitution Principle (LSP)","href":"/para_ruby/docs/solid-principles/liskov_substitution_principle","docId":"solid-principles/liskov_substitution_principle"},{"type":"link","label":"Interface Segregation Principle (ISP)","href":"/para_ruby/docs/solid-principles/interface_segregation_principle","docId":"solid-principles/interface_segregation_principle"},{"type":"link","label":"Dependency Inversion Principle (DIP)","href":"/para_ruby/docs/solid-principles/dependency_inversion_principle","docId":"solid-principles/dependency_inversion_principle"}],"href":"/para_ruby/docs/category/solid-principles"},{"type":"category","label":"Glossary","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Abstraction","href":"/para_ruby/docs/glossary/abstraction","docId":"glossary/abstraction"},{"type":"link","label":"Composition","href":"/para_ruby/docs/glossary/composition","docId":"glossary/composition"},{"type":"link","label":"Inheritance","href":"/para_ruby/docs/glossary/inheritance","docId":"glossary/inheritance"},{"type":"link","label":"Inversion of Control","href":"/para_ruby/docs/glossary/inversion of control","docId":"glossary/inversion of control"},{"type":"link","label":"Object Orientated Programming","href":"/para_ruby/docs/glossary/oop","docId":"glossary/oop"},{"type":"link","label":"Polymorphism","href":"/para_ruby/docs/glossary/polymorphism","docId":"glossary/polymorphism"}],"href":"/para_ruby/docs/category/glossary"}]},"docs":{"glossary/abstraction":{"id":"glossary/abstraction","title":"Abstraction","description":"Abstraction is the process of removing unnecessary details or complexities from a system or concept in order to focus on the essential characteristics or functionality. This allows for a more general or high-level view of the system or concept, which makes it easier to understand and manipulate. Abstraction is often used in computer science, where it is applied to various levels of a system, from the design and implementation of algorithms and data structures, to the design and use of software interfaces.","sidebar":"tutorialSidebar"},"glossary/composition":{"id":"glossary/composition","title":"Composition","description":"Composition is a concept in object-oriented programming where a class is made up of other classes. This allows for code reuse and flexibility, as a class can be composed of multiple classes that each have their own specific functionality. For example, a Car class can be composed of a Wheel class, an Engine class, and a Door class, each with their own methods and attributes. This allows the Car class to have all of the functionality of its composed classes without having to duplicate code.","sidebar":"tutorialSidebar"},"glossary/inheritance":{"id":"glossary/inheritance","title":"Inheritance","description":"Inheritance is the ability of a class to inherit characteristics and behavior from another class. This allows for code to be organized into a hierarchy of classes, where common behavior and attributes can be defined in a base class and then inherited by subclasses. This allows for code to be more reusable and maintainable, as subclasses can easily inherit and extend the behavior of their parent class. For example, a Vehicle class might define common attributes and behavior for all vehicles, such as a speed attribute and a move method. Then, specific types of vehicles, such as Car and Bike, could inherit from Vehicle and define their own unique behavior.","sidebar":"tutorialSidebar"},"glossary/inversion of control":{"id":"glossary/inversion of control","title":"Inversion of Control","description":"Inversion of control is a design principle in object-oriented programming where the flow of control is inverted compared to traditional procedural programming. In traditional programming, the code tells the program what to do, but in inversion of control, the program tells the code what to do. This is often achieved through the use of design patterns such as the factory pattern and the dependency injection pattern. Inversion of control allows for more modular and flexible code, as it decouples the different components of a program and allows them to be easily replaced or extended.","sidebar":"tutorialSidebar"},"glossary/oop":{"id":"glossary/oop","title":"Object Orientated Programming","description":"Object-oriented programming (OOP) is a programming paradigm that is based on the concept of \\"objects\\", which are data structures that contain both data and behavior. In Ruby, OOP is implemented through the use of classes, which define the structure and behavior of objects. These classes can be organized into hierarchies through inheritance, where a subclass can inherit characteristics and behavior from a parent class. OOP allows for code to be more modular, reusable, and maintainable, as objects can be easily created and manipulated, and common behavior can be defined and inherited across classes.","sidebar":"tutorialSidebar"},"glossary/polymorphism":{"id":"glossary/polymorphism","title":"Polymorphism","description":"Polymorphism is the ability of different objects to respond to the same method or message in different ways. This allows for objects to be treated uniformly, regardless of their specific type or class. For example, a collection of shapes (circles, squares, triangles, etc.) can all respond to the same area method, but each will calculate the area differently based on its specific type. This allows for code to be more reusable and maintainable, as new types of objects can be easily added without having to change existing code.","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"A Guide to OOP & Design Patterns in Ruby","description":"Written by ChatGPT","sidebar":"tutorialSidebar"},"paradigms":{"id":"paradigms","title":"What\'s a Paradigm?","description":"Some content with Markdown syntax. Check this api.","sidebar":"tutorialSidebar"},"solid-principles/dependency_inversion_principle":{"id":"solid-principles/dependency_inversion_principle","title":"Dependency Inversion Principle (DIP)","description":"The Dependency Inversion Principle (DIP) is a principle of object-oriented design that states that high-level modules should not depend on low-level modules, but rather both should depend on abstractions. This means that instead of directly depending on concrete implementations of classes, modules should depend on abstract interfaces or contracts. This allows for better code organization and maintainability, as well as flexibility to accommodate future changes in requirements. To implement the DIP, developers can use techniques such as abstraction, inversion of control, and dependency injection.","sidebar":"tutorialSidebar"},"solid-principles/interface_segregation_principle":{"id":"solid-principles/interface_segregation_principle","title":"Interface Segregation Principle (ISP)","description":"The Interface Segregation Principle (ISP) is a principle of object-oriented design that states that no client should be forced to depend on methods it does not use. This means that classes should have small, specific interfaces that only include the methods that are actually needed by the client classes. This allows for better code organization and maintainability, as well as flexibility to accommodate future changes in requirements. To implement the ISP, developers can use techniques such as abstraction and composition.","sidebar":"tutorialSidebar"},"solid-principles/liskov_substitution_principle":{"id":"solid-principles/liskov_substitution_principle","title":"Liskov Substitution Principle (LSP)","description":"The Liskov Substitution Principle (LSP) is a principle of object-oriented design that states that objects in a program should be replaceable with instances of their subtypes without affecting the correctness of the program. In other words, if a class is a subtype of another class, then objects of the subtype class should be able to be used wherever objects of the parent class are used without causing any problems. This allows for flexibility and maintainability in object-oriented design, as well as code reusability and extensibility. To implement the LSP, developers can use techniques such as polymorphism and inheritance.","sidebar":"tutorialSidebar"},"solid-principles/open_closed_principle":{"id":"solid-principles/open_closed_principle","title":"Open/Closed Principle (OCP)","description":"What is OCP?","sidebar":"tutorialSidebar"},"solid-principles/single_responsibility_principle":{"id":"solid-principles/single_responsibility_principle","title":"The Single Responsibility Principle","description":"The Single Responsibility Principle (SRP) is a principle of object-oriented programming (OOP) that states that a class should only have a single responsibility, or a single reason to change. In other words, a class should focus on one specific aspect of the problem domain, and should not be cluttered with unrelated responsibilities or functionality.","sidebar":"tutorialSidebar"},"solid-principles/the_five_principles":{"id":"solid-principles/the_five_principles","title":"What is SOLID","description":"SOLID is an acronym for five principles of object-oriented programming (OOP) that are designed to improve the design and maintainability of software. The principles are:","sidebar":"tutorialSidebar"}}}')}}]);