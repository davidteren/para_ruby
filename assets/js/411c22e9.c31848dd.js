"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[2738],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),c=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(o.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(n),h=i,b=u["".concat(o,".").concat(h)]||u[h]||p[h]||r;return n?a.createElement(b,s(s({ref:t},d),{},{components:n})):a.createElement(b,s({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=u;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:i,s[1]=l;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(7294),i=n(6010);const r="tabItem_Ymn6";function s(e){let{children:t,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,s),hidden:n},t)}},5488:(e,t,n)=>{n.d(t,{Z:()=>h});var a=n(7462),i=n(7294),r=n(6010),s=n(2389),l=n(7392),o=n(7094),c=n(2466);const d="tabList__CuJ",p="tabItem_LNqP";function u(e){var t;const{lazy:n,block:s,defaultValue:u,values:h,groupId:b,className:m}=e,f=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),g=h??f.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),y=(0,l.l)(g,((e,t)=>e.value===t.value));if(y.length>0)throw new Error(`Docusaurus error: Duplicate values "${y.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const k=null===u?u:u??(null==(t=f.find((e=>e.props.default)))?void 0:t.props.value)??f[0].props.value;if(null!==k&&!g.some((e=>e.value===k)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${k}" but none of its children has the corresponding value. Available values are: ${g.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:v,setTabGroupChoices:w}=(0,o.U)(),[S,N]=(0,i.useState)(k),_=[],{blockElementScrollPositionUntilNextRender:T}=(0,c.o5)();if(null!=b){const e=v[b];null!=e&&e!==S&&g.some((t=>t.value===e))&&N(e)}const P=e=>{const t=e.currentTarget,n=_.indexOf(t),a=g[n].value;a!==S&&(T(t),N(a),null!=b&&w(b,String(a)))},j=e=>{var t;let n=null;switch(e.key){case"Enter":P(e);break;case"ArrowRight":{const t=_.indexOf(e.currentTarget)+1;n=_[t]??_[0];break}case"ArrowLeft":{const t=_.indexOf(e.currentTarget)-1;n=_[t]??_[_.length-1];break}}null==(t=n)||t.focus()};return i.createElement("div",{className:(0,r.Z)("tabs-container",d)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":s},m)},g.map((e=>{let{value:t,label:n,attributes:s}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:S===t?0:-1,"aria-selected":S===t,key:t,ref:e=>_.push(e),onKeyDown:j,onClick:P},s,{className:(0,r.Z)("tabs__item",p,null==s?void 0:s.className,{"tabs__item--active":S===t})}),n??t)}))),n?(0,i.cloneElement)(f.filter((e=>e.props.value===S))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},f.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==S})))))}function h(e){const t=(0,s.Z)();return i.createElement(u,(0,a.Z)({key:String(t)},e))}},8977:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>c,toc:()=>p});var a=n(7462),i=(n(7294),n(3905)),r=n(5488),s=n(5162);const l={sidebar_position:4},o="Liskov Substitution Principle (LSP)",c={unversionedId:"solid-principles/liskov_substitution_principle",id:"solid-principles/liskov_substitution_principle",title:"Liskov Substitution Principle (LSP)",description:"The Liskov Substitution Principle (LSP) is a principle of object-oriented design that states that objects in a program should be replaceable with instances of their subtypes without affecting the correctness of the program. In other words, if a class is a subtype of another class, then objects of the subtype class should be able to be used wherever objects of the parent class are used without causing any problems. This allows for flexibility and maintainability in object-oriented design, as well as code reusability and extensibility. To implement the LSP, developers can use techniques such as polymorphism and inheritance.",source:"@site/docs/solid-principles/03_liskov_substitution_principle.md",sourceDirName:"solid-principles",slug:"/solid-principles/liskov_substitution_principle",permalink:"/para_ruby/docs/solid-principles/liskov_substitution_principle",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Open/Closed Principle (OCP)",permalink:"/para_ruby/docs/solid-principles/open_closed_principle"},next:{title:"Interface Segregation Principle (ISP)",permalink:"/para_ruby/docs/solid-principles/interface_segregation_principle"}},d={},p=[{value:"Code examples",id:"code-examples",level:2}],u={toc:p};function h(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"liskov-substitution-principle-lsp"},"Liskov Substitution Principle (LSP)"),(0,i.kt)("p",null,"The Liskov Substitution Principle (LSP) is a principle of object-oriented design that states that objects in a program should be replaceable with instances of their subtypes without affecting the correctness of the program. In other words, if a class is a subtype of another class, then objects of the subtype class should be able to be used wherever objects of the parent class are used without causing any problems. This allows for flexibility and maintainability in object-oriented design, as well as code reusability and extensibility. To implement the LSP, developers can use techniques such as ",(0,i.kt)("a",{parentName:"p",href:"/para_ruby/docs/glossary/polymorphism"},"polymorphism")," and ",(0,i.kt)("a",{parentName:"p",href:"/para_ruby/docs/glossary/inheritance"},"inheritance"),"."),(0,i.kt)("admonition",{title:"Explain the Liskov Substitution Principle (LSP) like I'm five",type:"info"},(0,i.kt)("blockquote",{parentName:"admonition"},(0,i.kt)("p",{parentName:"blockquote"},"The Liskov Substitution Principle is like a game of hide and seek. In hide and seek, there are different types of people who can play, like kids and adults. And even though kids and adults are different, they can still play the same game together. For example, if a kid is hiding, then an adult can still go and find them. And if an adult is hiding, then a kid can still go and find them. So even though kids and adults are different, they can still play hide and seek together without causing any problems. In object-oriented programming, the different types of people are like classes, and the game of hide and seek is like a program. The Liskov Substitution Principle says that objects of different classes should be able to be used together in a program without causing any problems."))),(0,i.kt)("h2",{id:"code-examples"},"Code examples"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"bad",label:"Bad",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},"class Rectangle\n  attr_accessor :width, :height\n\n  def initialize(width, height)\n    @width = width\n    @height = height\n  end\n\n  def area\n    @width * @height\n  end\nend\n\nclass Square < Rectangle\n  def initialize(side_length)\n    @width = side_length\n    @height = side_length\n  end\nend\n")),(0,i.kt)("p",null,"In this code, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Square")," class is a subclass of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Rectangle")," class. However, because a square's sides must be equal in length, setting the width and height attributes independently will violate the square's constraints. This means that a ",(0,i.kt)("inlineCode",{parentName:"p"},"Square")," object cannot be used in the same way as a ",(0,i.kt)("inlineCode",{parentName:"p"},"Rectangle")," object, violating the Liskov Substitution Principle.")),(0,i.kt)(s.Z,{value:"good",label:"Good",mdxType:"TabItem"},(0,i.kt)("p",null,"A better way to structure this code would be to make the ",(0,i.kt)("inlineCode",{parentName:"p"},"Rectangle")," class abstract and create a separate ",(0,i.kt)("inlineCode",{parentName:"p"},"Square")," class that implements its own area method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},"class Shape\n  def area\n    raise NotImplementedError\n  end\nend\n\nclass Rectangle < Shape\n  attr_accessor :width, :height\n\n  def initialize(width, height)\n    @width = width\n    @height = height\n  end\n\n  def area\n    @width * @height\n  end\nend\n\nclass Square < Shape\n  attr_accessor :side_length\n\n  def initialize(side_length)\n    @side_length = side_length\n  end\n\n  def area\n    @side_length ** 2\n  end\nend\n")),(0,i.kt)("p",null,"With this refactored code, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Rectangle")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Square")," classes are both subclasses of the abstract ",(0,i.kt)("inlineCode",{parentName:"p"},"Shape")," class, and both implement their own versions of the area method. This allows ",(0,i.kt)("inlineCode",{parentName:"p"},"Square")," objects to be used in the same way as ",(0,i.kt)("inlineCode",{parentName:"p"},"Rectangle")," objects, without violating the Liskov Substitution Principle.")),(0,i.kt)(s.Z,{value:"specs",label:"Specs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},"describe Shape do\n  describe '#area' do\n    it 'raises a NotImplementedError' do\n      shape = Shape.new\n      expect { shape.area }.to raise_error(NotImplementedError)\n    end\n  end\nend\n\ndescribe Rectangle do\n  describe '#area' do\n    it 'calculates the area of the rectangle' do\n      rectangle = Rectangle.new(4, 5)\n      expect(rectangle.area).to eq(20)\n    end\n  end\nend\n\ndescribe Square do\n  describe '#area' do\n    it 'calculates the area of the square' do\n      square = Square.new(4)\n      expect(square.area).to eq(16)\n    end\n  end\nend\n")),(0,i.kt)("p",null,"These tests ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"Rectangle")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Square")," classes can calculate their areas correctly, and that the ",(0,i.kt)("inlineCode",{parentName:"p"},"Shape")," class raises a ",(0,i.kt)("inlineCode",{parentName:"p"},"NotImplementedError")," when its ",(0,i.kt)("inlineCode",{parentName:"p"},"area")," method is called."))))}h.isMDXComponent=!0}}]);