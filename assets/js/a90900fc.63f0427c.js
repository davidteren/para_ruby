"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7515],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),h=i,f=d["".concat(l,".").concat(h)]||d[h]||u[h]||r;return n?a.createElement(f,s(s({ref:t},p),{},{components:n})):a.createElement(f,s({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6869:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:4},s="Liskov Substitution Principle (LSP)",o={unversionedId:"solid-principles/liskov_substitution_principle",id:"solid-principles/liskov_substitution_principle",title:"Liskov Substitution Principle (LSP)",description:"The Liskov Substitution Principle (LSP) is a principle of object-oriented design that states that objects in a program should be replaceable with instances of their subtypes without affecting the correctness of the program. In other words, if a class is a subtype of another class, then objects of the subtype class should be able to be used wherever objects of the parent class are used without causing any problems. This allows for flexibility and maintainability in object-oriented design, as well as code reusability and extensibility. To implement the LSP, developers can use techniques such as polymorphism and inheritance.",source:"@site/docs/solid-principles/liskov_substitution_principle.md",sourceDirName:"solid-principles",slug:"/solid-principles/liskov_substitution_principle",permalink:"/para_ruby/docs/solid-principles/liskov_substitution_principle",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Open/Closed Principle (OCP)",permalink:"/para_ruby/docs/solid-principles/open_closed_principle"},next:{title:"Interface Segregation Principle (ISP)",permalink:"/para_ruby/docs/solid-principles/interface_segregation_principle"}},l={},c=[],p={toc:c};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"liskov-substitution-principle-lsp"},"Liskov Substitution Principle (LSP)"),(0,i.kt)("p",null,"The Liskov Substitution Principle (LSP) is a principle of object-oriented design that states that objects in a program should be replaceable with instances of their subtypes without affecting the correctness of the program. In other words, if a class is a subtype of another class, then objects of the subtype class should be able to be used wherever objects of the parent class are used without causing any problems. This allows for flexibility and maintainability in object-oriented design, as well as code reusability and extensibility. To implement the LSP, developers can use techniques such as ",(0,i.kt)("a",{parentName:"p",href:"/para_ruby/docs/glossary/polymorphism"},"polymorphism")," and ",(0,i.kt)("a",{parentName:"p",href:"/para_ruby/docs/glossary/inheritance"},"inheritance"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("h4",{parentName:"blockquote",id:"explain-the-liskov-substitution-principle-lsp-like-im-five"},"Explain the Liskov Substitution Principle (LSP) like I'm five"),(0,i.kt)("p",{parentName:"blockquote"},"The Liskov Substitution Principle is like a game of hide and seek. In hide and seek, there are different types of people who can play, like kids and adults. And even though kids and adults are different, they can still play the same game together. For example, if a kid is hiding, then an adult can still go and find them. And if an adult is hiding, then a kid can still go and find them. So even though kids and adults are different, they can still play hide and seek together without causing any problems. In object-oriented programming, the different types of people are like classes, and the game of hide and seek is like a program. The Liskov Substitution Principle says that objects of different classes should be able to be used together in a program without causing any problems.")),(0,i.kt)("p",null,"Here are some Liskov Substitution Principle (LSP) code examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},'# Define a base Shape class\nclass Shape\n  # Define a method to calculate the area\n  def area\n    raise NotImplementedError, "Method not implemented"\n  end\nend\n\n# Define a Circle class that inherits from Shape\nclass Circle < Shape\n  # Initialize a circle with a radius\n  def initialize(radius)\n    @radius = radius\n  end\n\n  # Override the area method to calculate the area of a circle\n  def area\n    Math::PI * (@radius ** 2)\n  end\nend\n\n# Define a Square class that inherits from Shape\nclass Square < Shape\n  # Initialize a square with a side length\n  def initialize(side)\n    @side = side\n  end\n\n  # Override the area method to calculate the area of a square\n  def area\n    @side ** 2\n  end\nend\n\n# Define a Shapes class that can calculate the total area of a collection of shapes\nclass Shapes\n  # Initialize a shapes collection with an array of shapes\n  def initialize(shapes)\n    @shapes = shapes\n  end\n\n  # Calculate the total area of all shapes in the collection\n  def total_area\n    @shapes.map(&:area).sum\n  end\nend\n\n# Example usage\n\n# Create a circle with radius 2\ncircle = Circle.new(2)\n\n# Create a square with side length 2\nsquare = Square.new(2)\n\n# Create a shapes collection with the circle and square\nshapes = Shapes.new([circle, square])\n\n# Calculate the total area of all shapes in the collection\nputs shapes.total_area\n# Output: 12.566370614359172\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},'RSpec.describe Shapes do\n  let(:circle) { Circle.new(2) }\n  let(:square) { Square.new(2) }\n  let(:shapes) { Shapes.new([circle, square]) }\n\n  it "calculates the total area of a collection of shapes" do\n    expect(shapes.total_area).to eq(16.566370614359172)\n  end\nend\n')),(0,i.kt)("p",null,"In this example, the Circle and Square classes both inherit from the Shape class, and they each implement the area method in a way that is specific to their respective shape."))}u.isMDXComponent=!0}}]);