"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9756],{3905:(e,n,a)=>{a.d(n,{Zo:()=>c,kt:()=>m});var t=a(7294);function s(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function r(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){s(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function i(e,n){if(null==e)return{};var a,t,s=function(e,n){if(null==e)return{};var a,t,s={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(s[a]=e[a]);return s}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=t.createContext({}),d=function(e){var n=t.useContext(l),a=n;return e&&(a="function"==typeof e?e(n):r(r({},n),e)),a},c=function(e){var n=d(e.components);return t.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var a=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=d(a),m=s,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||o;return a?t.createElement(h,r(r({ref:n},c),{},{components:a})):t.createElement(h,r({ref:n},c))}));function m(e,n){var a=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var o=a.length,r=new Array(o);r[0]=u;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,r[1]=i;for(var d=2;d<o;d++)r[d]=a[d];return t.createElement.apply(null,r)}return t.createElement.apply(null,a)}u.displayName="MDXCreateElement"},1434:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>k,contentTitle:()=>f,default:()=>P,frontMatter:()=>g,metadata:()=>v,toc:()=>x});var t=a(7462),s=a(7294),o=a(3905),r=a(6010),i=a(2389),l=a(7392),d=a(7094),c=a(2466);const p="tabList__CuJ",u="tabItem_LNqP";function m(e){var n;const{lazy:a,block:o,defaultValue:i,values:m,groupId:h,className:b}=e,y=s.Children.map(e.children,(e=>{if((0,s.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),g=m??y.map((e=>{let{props:{value:n,label:a,attributes:t}}=e;return{value:n,label:a,attributes:t}})),f=(0,l.l)(g,((e,n)=>e.value===n.value));if(f.length>0)throw new Error(`Docusaurus error: Duplicate values "${f.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const v=null===i?i:i??(null==(n=y.find((e=>e.props.default)))?void 0:n.props.value)??y[0].props.value;if(null!==v&&!g.some((e=>e.value===v)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${v}" but none of its children has the corresponding value. Available values are: ${g.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:k,setTabGroupChoices:x}=(0,d.U)(),[w,P]=(0,s.useState)(v),T=[],{blockElementScrollPositionUntilNextRender:_}=(0,c.o5)();if(null!=h){const e=k[h];null!=e&&e!==w&&g.some((n=>n.value===e))&&P(e)}const S=e=>{const n=e.currentTarget,a=T.indexOf(n),t=g[a].value;t!==w&&(_(n),P(t),null!=h&&x(h,String(t)))},E=e=>{var n;let a=null;switch(e.key){case"Enter":S(e);break;case"ArrowRight":{const n=T.indexOf(e.currentTarget)+1;a=T[n]??T[0];break}case"ArrowLeft":{const n=T.indexOf(e.currentTarget)-1;a=T[n]??T[T.length-1];break}}null==(n=a)||n.focus()};return s.createElement("div",{className:(0,r.Z)("tabs-container",p)},s.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":o},b)},g.map((e=>{let{value:n,label:a,attributes:o}=e;return s.createElement("li",(0,t.Z)({role:"tab",tabIndex:w===n?0:-1,"aria-selected":w===n,key:n,ref:e=>T.push(e),onKeyDown:E,onClick:S},o,{className:(0,r.Z)("tabs__item",u,null==o?void 0:o.className,{"tabs__item--active":w===n})}),a??n)}))),a?(0,s.cloneElement)(y.filter((e=>e.props.value===w))[0],{className:"margin-top--md"}):s.createElement("div",{className:"margin-top--md"},y.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==w})))))}function h(e){const n=(0,i.Z)();return s.createElement(m,(0,t.Z)({key:String(n)},e))}const b="tabItem_Ymn6";function y(e){let{children:n,hidden:a,className:t}=e;return s.createElement("div",{role:"tabpanel",className:(0,r.Z)(b,t),hidden:a},n)}const g={sidebar_position:2},f="The Single Responsibility Principle",v={unversionedId:"solid-principles/single_responsibility_principle",id:"solid-principles/single_responsibility_principle",title:"The Single Responsibility Principle",description:"The Single Responsibility Principle (SRP) is a principle of object-oriented programming (OOP) that states that a class",source:"@site/docs/solid-principles/single_responsibility_principle.md",sourceDirName:"solid-principles",slug:"/solid-principles/single_responsibility_principle",permalink:"/para_ruby/docs/solid-principles/single_responsibility_principle",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"What is SOLID",permalink:"/para_ruby/docs/solid-principles/the_five_principles"},next:{title:"Open/Closed Principle (OCP)",permalink:"/para_ruby/docs/solid-principles/open_closed_principle"}},k={},x=[{value:"Examples A",id:"examples-a",level:2},{value:"Example A1",id:"example-a1",level:3},{value:"Example A2",id:"example-a2",level:3},{value:"Example A3",id:"example-a3",level:3},{value:"Example A4",id:"example-a4",level:3},{value:"Example A5",id:"example-a5",level:3},{value:"Examples B",id:"examples-b",level:2},{value:"Example B1",id:"example-b1",level:3},{value:"Example B2",id:"example-b2",level:3}],w={toc:x};function P(e){let{components:n,...a}=e;return(0,o.kt)("wrapper",(0,t.Z)({},w,a,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"the-single-responsibility-principle"},"The Single Responsibility Principle"),(0,o.kt)("p",null,"The Single Responsibility Principle (SRP) is a principle of object-oriented programming (OOP) that states that a class\nshould only have a single responsibility, or a single reason to change. In other words, a class should focus on one\nspecific aspect of the problem domain, and should not be cluttered with unrelated responsibilities or functionality."),(0,o.kt)("admonition",{title:"Explain The Single Responsibility Principle like I'm five",type:"info"},(0,o.kt)("blockquote",{parentName:"admonition"},(0,o.kt)("p",{parentName:"blockquote"},"The Single Responsibility Principle is like a job. Everyone has a different job, and they do their job really well.\nFor example, one person might be really good at making cookies, and another person might be really good at washing\ndishes. If they each just do their own job, then they will be able to make lots of cookies and wash lots of dishes.\nBut\nif they try to do each other's job, then they might not be as good at it, and they might not be able to make as many\ncookies or wash as many dishes. So it's better for everyone to just do their own job and not try to do other people's\njobs."))),(0,o.kt)("p",null,"In Ruby, the SRP can be applied by defining separate classes for different responsibilities, and using methods and\nattributes to encapsulate the relevant data and behavior. For example, instead of having a single Person class that\nhandles both the person's name and age, we could define a Person class and a separate Age class:"),(0,o.kt)("h2",{id:"examples-a"},"Examples A"),(0,o.kt)("h3",{id:"example-a1"},"Example A1"),(0,o.kt)(h,{mdxType:"Tabs"},(0,o.kt)(y,{value:"ruby",label:"Ruby",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'class Person\n  attr_accessor :name\n\n  def initialize(name)\n    @name = name\n  end\nend\n\nclass Age\n  attr_accessor :age\n\n  def initialize(age)\n    @age = age\n  end\nend\n\nperson = Person.new("John")\nage = Age.new(25)\n')),(0,o.kt)("p",null,"This approach allows us to focus each class on a specific responsibility, and makes it easier to maintain and modify the\ncode in the future."),(0,o.kt)("p",null,"This means that a class should not be responsible for multiple, unrelated tasks or responsibilities. Instead, each class\nshould have a clear and well-defined purpose and should only be responsible for the tasks that are necessary to fulfill\nthat purpose.")),(0,o.kt)(y,{value:"specs",label:"Specs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'describe Person do\n  describe "#initialize" do\n    it "should set the name attribute" do\n      person = Person.new("John")\n      expect(person.name).to eq("John")\n    end\n  end\nend\n\nRSpec.describe Age do\n  describe "#initialize" do\n    it "should set the age attribute" do\n      age = Age.new(25)\n      expect(age.age).to eq(25)\n    end\n  end\nend\n')))),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"example-a2"},"Example A2"),(0,o.kt)(h,{mdxType:"Tabs"},(0,o.kt)(y,{value:"ruby",label:"Ruby",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'# Define a class called "Person"\nclass Person\n  # Define attributes for the Person class\n  attr_accessor :name, :age\n\n  # Define a constructor method for initializing new Person objects\n  def initialize(name, age)\n    @name = name\n    @age = age\n  end\n\n  # Define a method for greeting another Person object\n  def greet(other_person)\n    "Hi #{other_person.name}, I\'m #{@name} and I\'m #{@age} years old."\n  end\nend\n\n# Define a class called "Employee"\nclass Employee < Person\n  # Define attributes for the Employee class\n  attr_accessor :title, :salary\n\n  # Define a constructor method for initializing new Employee objects\n  def initialize(name, age, title, salary)\n    # Use the super keyword to initialize the name and age attributes from the parent Person class\n    super(name, age)\n    @title = title\n    @salary = salary\n  end\n\n  # Define a method for calculating the annual salary for an Employee\n  def calculate_annual_salary\n    @salary * 12\n  end\nend\n\n# Create a new Employee object\nemployee = Employee.new("John", 25, "Software Engineer", 75000)\n\n# Use the Employee\'s calculate_annual_salary method to calculate their annual salary\nannual_salary = employee.calculate_annual_salary\n')),(0,o.kt)("p",null,"In this code, we define two classes: Person and Employee. The Person class is responsible for modeling a person and\nproviding a method for greeting another person. The Employee class is responsible for modeling an employee and providing\na method for calculating their annual salary. By separating these two responsibilities into separate classes, we are\nfollowing the SRP and making our code more modular and maintainable."),(0,o.kt)("p",null,"In Ruby, this principle can be applied by ensuring that each class has a well-defined and narrowly focused purpose, and\nby avoiding the inclusion of unnecessary or unrelated functionality.")),(0,o.kt)(y,{value:"specs",label:"Specs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'RSpec.describe Person do\n  describe "#initialize" do\n    it "should set the name and age attributes" do\n      person = Person.new("John", 25)\n      expect(person.name).to eq("John")\n      expect(person.age).to eq(25)\n    end\n  end\n\n  describe "#greet" do\n    it "should greet another person" do\n      person1 = Person.new("John", 25)\n      person2 = Person.new("Jane", 30)\n      expect(person1.greet(person2)).to eq("Hi Jane, I\'m John and I\'m 25 years old.")\n    end\n  end\nend\n\nRSpec.describe Employee do\n  describe "#initialize" do\n    it "should set the name, age, title, and salary attributes" do\n      employee = Employee.new("John", 25, "Software Engineer", 75000)\n      expect(employee.name).to eq("John")\n      expect(employee.age).to eq(25)\n      expect(employee.title).to eq("Software Engineer")\n      expect(employee.salary).to eq(75000)\n    end\n  end\n\n  describe "#calculate_annual_salary" do\n    it "should calculate the annual salary for an employee" do\n      employee = Employee.new("John", 25, "Software Engineer", 75000)\n      expect(employee.calculate_annual_salary).to eq(900000)\n    end\n  end\nend\n')))),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"example-a3"},"Example A3"),(0,o.kt)(h,{mdxType:"Tabs"},(0,o.kt)(y,{value:"ruby",label:"Ruby",default:!0,mdxType:"TabItem"},(0,o.kt)("p",null,"For example, consider a class that represents a bank account. The Single Responsibility Principle would dictate that\nthis class should be responsible only for storing and manipulating information about the account (e.g. balance,\ntransactions), and not for other tasks such as rendering HTML or sending email notifications. This would help to keep\nthe class focused and easier to maintain."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"class BankAccount\n  attr_accessor :balance\n\n  def initialize(balance)\n    @balance = balance\n  end\n\n  def deposit(amount)\n    @balance += amount\n  end\n\n  def withdraw(amount)\n    @balance -= amount\n  end\nend\n")),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"BankAccount")," class only has a single responsibility, which is to store and manipulate information about the\naccount. It does not include any unrelated functionality such as rendering HTML or sending email notifications. This\nmakes the class more focused and easier to maintain.")),(0,o.kt)(y,{value:"specs",label:"Specs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'RSpec.describe BankAccount do\n  describe "#initialize" do\n    it "should set the balance attribute" do\n      account = BankAccount.new(100)\n      expect(account.balance).to eq(100)\n    end\n  end\n\n  describe "#deposit" do\n    it "should increase the balance by the given amount" do\n      account = BankAccount.new(100)\n      account.deposit(50)\n      expect(account.balance).to eq(150)\n    end\n  end\n\n  describe "#withdraw" do\n    it "should decrease the balance by the given amount" do\n      account = BankAccount.new(100)\n      account.withdraw(50)\n      expect(account.balance).to eq(50)\n    end\n  end\nend\n\n')))),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"example-a4"},"Example A4"),(0,o.kt)(h,{mdxType:"Tabs"},(0,o.kt)(y,{value:"ruby",label:"Ruby",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'# Define a class called "Person" that only has a single responsibility: managing information about a person\nclass Person\n  attr_accessor :name, :age\n\n  def initialize(name, age)\n    @name = name\n    @age = age\n  end\nend\n\n# Define a separate class called "EmailSender" that only has a single responsibility: sending emails\nclass EmailSender\n  def send_email(to, subject, body)\n    # Send the email\n  end\nend\n\n# Define a separate class called "Database" that only has a single responsibility: storing data\nclass Database\n  def save(data)\n    # Save the data to the database\n  end\nend\n\n# Create a new Person object\nperson = Person.new("John", 25)\n\n# Create an EmailSender object and use it to send an email\nemail_sender = EmailSender.new\nemail_sender.send_email("jane@example.com", "Hello!", "Hi there!")\n\n# Create a Database object and use it to save data\ndatabase = Database.new\ndatabase.save({name: "John", age: 25})\n')),(0,o.kt)("p",null,"In this code, we define three separate classes, each with a clear and focused responsibility. The Person class is\nresponsible for managing information about a person, the EmailSender class is responsible for sending emails, and the\nDatabase class is responsible for storing data. This approach helps to promote code that is more modular, reusable, and\nmaintainable.")),(0,o.kt)(y,{value:"specs",label:"Specs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'RSpec.describe Person do\n  describe "#initialize" do\n    it "should set the name and age attributes" do\n      person = Person.new("John", 25)\n      expect(person.name).to eq("John")\n      expect(person.age).to eq(25)\n    end\n  end\nend\n\nRSpec.describe EmailSender do\n  describe "#send_email" do\n    it "should send an email to the given recipient" do\n      email_sender = EmailSender.new\n      expect(email_sender.send_email("jane@example.com", "Hello!", "Hi there!")).to eq(true)\n    end\n  end\nend\n\nRSpec.describe Database do\n  describe "#save" do\n    it "should save the given data to the database" do\n      database = Database.new\n      expect(database.save({name: "John", age: 25})).to eq(true)\n    end\n  end\nend\n')))),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"example-a5"},"Example A5"),(0,o.kt)(h,{mdxType:"Tabs"},(0,o.kt)(y,{value:"ruby",label:"Ruby",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'# Define a class called "Person"\nclass Person\n  # Define attributes for the Person class\n  attr_accessor :name, :age\n\n  # Define a constructor method for initializing new Person objects\n  def initialize(name, age)\n    @name = name\n    @age = age\n  end\n\n  # Define a method for greeting another Person object\n  def greet(other_person)\n    "Hi #{other_person.name}, I\'m #{@name} and I\'m #{@age} years old."\n  end\nend\n\n# Define a separate class called "PersonValidator" to handle validation\nclass PersonValidator\n  # Define a method for validating a Person object\n  def validate(person)\n    # Check if the person\'s name and age are valid\n    if person.name.nil? || person.age.nil?\n      raise "Invalid person: name and age are required"\n    end\n  end\nend\n\n# Create a new Person object\np1 = Person.new("John", 25)\n\n# Create a new PersonValidator object\nvalidator = PersonValidator.new\n\n# Validate the Person object using the PersonValidator\nvalidator.validate(p1)\n')),(0,o.kt)("p",null,"In this code, we define two classes: Person and PersonValidator. The Person class is responsible for modeling a person's\nname and age, and has a greet method for greeting another person. The PersonValidator class is responsible for\nvalidating a Person object, and has a validate method that checks if the person's name and age are valid. By separating\nthe validation logic into a separate class, we are following the Single Responsibility Principle and ensuring that each\nclass has a clear and well-defined responsibility. This can improve the maintainability and re-usability of the code.")),(0,o.kt)(y,{value:"specs",label:"Specs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'RSpec.describe Person do\n  describe "#initialize" do\n    it "should set the name and age attributes" do\n      person = Person.new("John", 25)\n      expect(person.name).to eq("John")\n      expect(person.age).to eq(25)\n    end\n  end\n\n  describe "#greet" do\n    it "should greet another person" do\n      person1 = Person.new("John", 25)\n      person2 = Person.new("Jane", 30)\n      expect(person1.greet(person2)).to eq("Hi Jane, I\'m John and I\'m 25 years old.")\n    end\n  end\nend\n\nRSpec.describe PersonValidator do\n  describe "#validate" do\n    it "should raise an error if the person is invalid" do\n      person = Person.new(nil, nil)\n      validator = PersonValidator.new\n      expect { validator.validate(person) }.to raise_error("Invalid person: name and age are required")\n    end\n\n    it "should not raise an error if the person is valid" do\n      person = Person.new("John", 25)\n      validator = PersonValidator.new\n      expect { validator.validate(person) }.not_to raise_error\n    end\n  end\nend\n')))),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"examples-b"},"Examples B"),(0,o.kt)("h3",{id:"example-b1"},"Example B1"),(0,o.kt)(h,{mdxType:"Tabs"},(0,o.kt)(y,{value:"ruby",label:"Ruby",default:!0,mdxType:"TabItem"},(0,o.kt)("p",null,"Here is an advanced code example of the Single Responsibility Principle (SRP) in Ruby with inheritance:"),(0,o.kt)("p",null,"A Person class that manages a person's name and age, and a Student class that inherits from Person and adds a student\nID, a Teacher class that inherits from Person and adds a subject and salary, and a Course class that manages a course's\nname, teacher, and students:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"class Person\n  attr_accessor :name, :age\n\n  def initialize(name, age)\n    @name = name\n    @age = age\n  end\nend\n\nclass Student < Person\n  attr_accessor :id\n\n  def initialize(name, age, id)\n    super(name, age)\n    @id = id\n  end\nend\n\nclass Teacher < Person\n  attr_accessor :subject, :salary\n\n  def initialize(name, age, subject, salary)\n    super(name, age)\n    @subject = subject\n    @salary = salary\n  end\nend\n\nclass Course\n  attr_accessor :name, :teacher, :students\n\n  def initialize(name, teacher, students)\n    @name = name\n    @teacher = teacher\n    @students = students\n  end\n\n  def add_student(student)\n    @students << student\n  end\n\n  def remove_student(student)\n    @students.delete(student)\n  end\nend\n")),(0,o.kt)("p",null,"In this example, the Person class only manages a person's name and age, the Student and Teacher classes only manage\nadditional attributes specific to students and teachers, and the Course class only manages a course's name, teacher, and\nstudents. This promotes code that is more modular and maintainable.")),(0,o.kt)(y,{value:"specs",label:"Specs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'RSpec.describe Person do\n  describe \'#initialize\' do\n    it \'initializes a person with a name and age\' do\n      person = Person.new(\'John Doe\', 30)\n\n      expect(person.name).to eq(\'John Doe\')\n      expect(person.age).to eq(30)\n    end\n  end\nend\n\nRSpec.describe Teacher do\n  subject(:teacher) { described_class.new("Jane", 30, "Math", 50000) }\n\n  describe "#initialize" do\n    it "sets the teacher\'s name" do\n      expect(teacher.name).to eq("Jane")\n    end\n\n    it "sets the teacher\'s age" do\n      expect(teacher.age).to eq(30)\n    end\n\n    it "sets the teacher\'s subject" do\n      expect(teacher.subject).to eq("Math")\n    end\n\n    it "sets the teacher\'s salary" do\n      expect(teacher.salary).to eq(50000)\n    end\n  end\nend\n\nRSpec.describe Course do\n  let(:teacher) { Teacher.new("Jane", 30, "Math", 50000) }\n  let(:students) { ["John", "Sally", "Dave"] }\n  subject(:course) { described_class.new("Algebra 101", teacher, students) }\n\n  describe "#initialize" do\n    it "sets the course\'s name" do\n      expect(course.name).to eq("Algebra 101")\n    end\n\n    it "sets the course\'s teacher" do\n      expect(course.teacher).to eq(teacher)\n    end\n\n    it "sets the course\'s students" do\n      expect(course.students).to eq(students)\n    end\n  end\n\n  describe "#add_student" do\n    it "adds a student to the course" do\n      course.add_student("Mark")\n      expect(course.students).to include("Mark")\n    end\n  end\n\n  describe "#remove_student" do\n    it "removes a student from the course" do\n      course.remove_student("Sally")\n      expect(course.students).not_to include("Sally")\n    end\n  end\nend\n')))),(0,o.kt)("h3",{id:"example-b2"},"Example B2"),(0,o.kt)(h,{mdxType:"Tabs"},(0,o.kt)(y,{value:"ruby",label:"Ruby",default:!0,mdxType:"TabItem"},(0,o.kt)("p",null,"Here is an advanced code example of the Single Responsibility Principle (SRP) in Ruby with inheritance, featuring a\nCalculator class that provides methods for performing arithmetic operations, a ScientificCalculator class that inherits\nfrom Calculator and adds methods for scientific functions, and a History class that manages a history of calculations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"\nclass Calculator\n  def add(a, b)\n    a + b\n  end\n\n  def subtract(a, b)\n    a - b\n  end\n\n  def multiply(a, b)\n    a * b\n  end\n\n  def divide(a, b)\n    a / b\n  end\nend\n\nclass ScientificCalculator < Calculator\n  def square_root(a)\n    Math.sqrt(a)\n  end\n\n  def logarithm(a)\n    Math.log(a)\n  end\n\n  def exponent(a, b)\n    a ** b\n  end\n\n  def factorial(a)\n    (1 .. a).inject(:*) || 1\n  end\nend\n\nclass History\n  def self.add(calculation)\n    @history ||= []\n    @history << calculation\n  end\n\n  def self.clear\n    @history = []\n  end\n\n  def self.print\n    @history.each do |calculation|\n      puts calculation\n    end\n  end\nend\n"))),(0,o.kt)(y,{value:"specs",label:"Specs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'RSpec.describe Calculator do\n  let(:calculator) { Calculator.new }\n\n  describe "#add" do\n    it "adds two numbers" do\n      expect(calculator.add(2, 3)).to eq(5)\n    end\n  end\n\n  describe "#subtract" do\n    it "subtracts two numbers" do\n      expect(calculator.subtract(5, 3)).to eq(2)\n    end\n  end\n\n  describe "#multiply" do\n    it "multiplies two numbers" do\n      expect(calculator.multiply(2, 3)).to eq(6)\n    end\n  end\n\n  describe "#divide" do\n    it "divides two numbers" do\n      expect(calculator.divide(6, 3)).to eq(2)\n    end\n\n    it "raises an error if the second argument is zero" do\n      expect { calculator.divide(6, 0) }.to raise_error(ZeroDivisionError)\n    end\n  end\nend\n\nRSpec.describe ScientificCalculator do\n  let(:calculator) { ScientificCalculator.new }\n\n  describe "#square_root" do\n    it "calculates the square root of a number" do\n      expect(calculator.square_root(9)).to eq(3)\n    end\n  end\n\n  describe "#logarithm" do\n    it "calculates the logarithm of a number" do\n      expect(calculator.logarithm(100)).to eq(4.605170185988092)\n    end\n  end\n\n  describe "#exponent" do\n    it "raises a number to a given power" do\n      expect(calculator.exponent(2, 3)).to eq(8)\n    end\n  end\n\n  describe "#factorial" do\n    it "calculates the factorial of a number" do\n      expect(calculator.factorial(5)).to eq(120)\n    end\n  end\nend\n\nRSpec.describe History do\n  describe ".add" do\n    it "adds a calculation to the history" do\n      History.add("2 + 3 = 5")\n      expect(History.instance_variable_get(:@history)).to eq(["2 + 3 = 5"])\n    end\n  end\n\n  describe ".clear" do\n    it "clears the history" do\n      History.instance_variable_set(:@history, ["2 + 3 = 5"])\n      History.clear\n      expect(History.instance_variable_get(:@history)).to eq([])\n    end\n  end\n\n  describe ".print" do\n    it "prints the history to the console" do\n      History.instance_variable_set(:@history, ["2 + 3 = 5", "4 + 5 = 9"])\n      expect { History.print }.to output("2 + 3 = 5\\n4 + 5 = 9\\n").to_stdout\n    end\n  end\nend\n')))))}P.isMDXComponent=!0}}]);