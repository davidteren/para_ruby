"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1626],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),h=o,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||i;return t?r.createElement(m,a(a({ref:n},p),{},{components:t})):r.createElement(m,a({ref:n},p))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=t[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},4943:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=t(7462),o=(t(7294),t(3905));const i={sidebar_position:6},a="Dependency Inversion Principle (DIP)",s={unversionedId:"solid-principles/dependency_inversion_principle",id:"solid-principles/dependency_inversion_principle",title:"Dependency Inversion Principle (DIP)",description:"The Dependency Inversion Principle (DIP) is a principle of object-oriented design that states that high-level modules should not depend on low-level modules, but rather both should depend on abstractions. This means that instead of directly depending on concrete implementations of classes, modules should depend on abstract interfaces or contracts. This allows for better code organization and maintainability, as well as flexibility to accommodate future changes in requirements. To implement the DIP, developers can use techniques such as abstraction, inversion of control, and dependency injection.",source:"@site/docs/solid-principles/dependency_inversion_principle.md",sourceDirName:"solid-principles",slug:"/solid-principles/dependency_inversion_principle",permalink:"/para_ruby/docs/solid-principles/dependency_inversion_principle",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Interface Segregation Principle (ISP)",permalink:"/para_ruby/docs/solid-principles/interface_segregation_principle"},next:{title:"Glossary",permalink:"/para_ruby/docs/category/glossary"}},l={},c=[],p={toc:c};function d(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"dependency-inversion-principle-dip"},"Dependency Inversion Principle (DIP)"),(0,o.kt)("p",null,"The Dependency Inversion Principle (DIP) is a principle of object-oriented design that states that high-level modules should not depend on low-level modules, but rather both should depend on abstractions. This means that instead of directly depending on concrete implementations of classes, modules should depend on abstract interfaces or contracts. This allows for better code organization and maintainability, as well as flexibility to accommodate future changes in requirements. To implement the DIP, developers can use techniques such as ",(0,o.kt)("a",{parentName:"p",href:"/para_ruby/docs/glossary/abstraction"},"abstraction"),", ",(0,o.kt)("a",{parentName:"p",href:"/para_ruby/docs/glossary/inversion%20of%20control"},"inversion of control"),", and dependency injection."),(0,o.kt)("admonition",{title:"Explain Dependency Inversion Principle (DIP) like I'm five",type:"info"},(0,o.kt)("blockquote",{parentName:"admonition"},(0,o.kt)("p",{parentName:"blockquote"},"The Dependency Inversion Principle is like a toy robot. A toy robot can do different things, like walk and talk and dance. And even though the robot can do all these different things, it doesn't have to do them all by itself. Instead, it can use other things to help it do the things it wants to do. For example, the robot might use batteries to make it move, and a speaker to make it talk. And even though the robot is using batteries and a speaker, it doesn't have to know how the batteries and the speaker work. It just has to know what they can do for it. In object-oriented programming, the toy robot is like a high-level module, and the batteries and the speaker are like low-level modules. The Dependency Inversion Principle says that high-level modules should use low-level modules without knowing how they work, so that the high-level modules can be more flexible and reusable."))))}d.isMDXComponent=!0}}]);