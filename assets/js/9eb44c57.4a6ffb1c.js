"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9140],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(t),m=a,y=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return t?r.createElement(y,s(s({ref:n},p),{},{components:t})):r.createElement(y,s({ref:n},p))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=u;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=t[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5162:(e,n,t)=>{t.d(n,{Z:()=>s});var r=t(7294),a=t(6010);const o="tabItem_Ymn6";function s(e){let{children:n,hidden:t,className:s}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(o,s),hidden:t},n)}},5488:(e,n,t)=>{t.d(n,{Z:()=>m});var r=t(7462),a=t(7294),o=t(6010),s=t(2389),i=t(7392),l=t(7094),c=t(2466);const p="tabList__CuJ",d="tabItem_LNqP";function u(e){var n;const{lazy:t,block:s,defaultValue:u,values:m,groupId:y,className:b}=e,h=a.Children.map(e.children,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),f=m??h.map((e=>{let{props:{value:n,label:t,attributes:r}}=e;return{value:n,label:t,attributes:r}})),P=(0,i.l)(f,((e,n)=>e.value===n.value));if(P.length>0)throw new Error(`Docusaurus error: Duplicate values "${P.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const v=null===u?u:u??(null==(n=h.find((e=>e.props.default)))?void 0:n.props.value)??h[0].props.value;if(null!==v&&!f.some((e=>e.value===v)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${v}" but none of its children has the corresponding value. Available values are: ${f.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:g,setTabGroupChoices:w}=(0,l.U)(),[k,x]=(0,a.useState)(v),O=[],{blockElementScrollPositionUntilNextRender:_}=(0,c.o5)();if(null!=y){const e=g[y];null!=e&&e!==k&&f.some((n=>n.value===e))&&x(e)}const C=e=>{const n=e.currentTarget,t=O.indexOf(n),r=f[t].value;r!==k&&(_(n),x(r),null!=y&&w(y,String(r)))},T=e=>{var n;let t=null;switch(e.key){case"Enter":C(e);break;case"ArrowRight":{const n=O.indexOf(e.currentTarget)+1;t=O[n]??O[0];break}case"ArrowLeft":{const n=O.indexOf(e.currentTarget)-1;t=O[n]??O[O.length-1];break}}null==(n=t)||n.focus()};return a.createElement("div",{className:(0,o.Z)("tabs-container",p)},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":s},b)},f.map((e=>{let{value:n,label:t,attributes:s}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:k===n?0:-1,"aria-selected":k===n,key:n,ref:e=>O.push(e),onKeyDown:T,onClick:C},s,{className:(0,o.Z)("tabs__item",d,null==s?void 0:s.className,{"tabs__item--active":k===n})}),t??n)}))),t?(0,a.cloneElement)(h.filter((e=>e.props.value===k))[0],{className:"margin-top--md"}):a.createElement("div",{className:"margin-top--md"},h.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==k})))))}function m(e){const n=(0,s.Z)();return a.createElement(u,(0,r.Z)({key:String(n)},e))}},5013:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var r=t(7462),a=(t(7294),t(3905)),o=t(5488),s=t(5162);const i={sidebar_position:3},l="Open/Closed Principle (OCP)",c={unversionedId:"solid-principles/open_closed_principle",id:"solid-principles/open_closed_principle",title:"Open/Closed Principle (OCP)",description:"What is OCP?",source:"@site/docs/solid-principles/02_open_closed_principle.md",sourceDirName:"solid-principles",slug:"/solid-principles/open_closed_principle",permalink:"/para_ruby/docs/solid-principles/open_closed_principle",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"The Single Responsibility Principle (SRP)",permalink:"/para_ruby/docs/solid-principles/single_responsibility_principle"},next:{title:"Liskov Substitution Principle (LSP)",permalink:"/para_ruby/docs/solid-principles/liskov_substitution_principle"}},p={},d=[{value:"What is OCP?",id:"what-is-ocp",level:2},{value:"Code examples",id:"code-examples",level:2}],u={toc:d};function m(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"openclosed-principle-ocp"},"Open/Closed Principle (OCP)"),(0,a.kt)("h2",{id:"what-is-ocp"},"What is OCP?"),(0,a.kt)("p",null,"The Open/Closed Principle (OCP) is a principle of object-oriented design that states that software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. This means that new functionality can be added to existing classes without changing their existing code. This allows for code reusability and maintainability, as well as flexibility to accommodate future changes in requirements. To implement the OCP, developers can use techniques such as ",(0,a.kt)("a",{parentName:"p",href:"/para_ruby/docs/glossary/abstraction"},"abstraction"),", ",(0,a.kt)("a",{parentName:"p",href:"/para_ruby/docs/glossary/polymorphism"},"polymorphism"),", and ",(0,a.kt)("a",{parentName:"p",href:"/para_ruby/docs/glossary/inheritance"},"inheritance"),"."),(0,a.kt)("admonition",{title:"Explain like I'm five.",type:"info"},(0,a.kt)("blockquote",{parentName:"admonition"},(0,a.kt)("p",{parentName:"blockquote"},"The Open/Closed Principle is like a box. You can put things inside the box and take things out, but you can't change the box itself. This is good because you can use the same box over and over again and it will still work the same way. And if you want to put a different kind of thing in the box, you can just make a new box that is the same size but has a different shape or color. This way, you can keep using the old box and the new box without having to change anything."))),(0,a.kt)("h2",{id:"code-examples"},"Code examples"),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"bad",label:"Bad",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"class PaymentProcessor\n  def process(order)\n    case order.payment_type\n      when 'credit_card'\n        process_credit_card(order)\n      when 'paypal'\n        process_paypal(order)\n      when 'stripe'\n        process_stripe(order)\n    end\n  end\n\n  def process_credit_card(order)\n    # Credit card processing logic\n  end\n\n  def process_paypal(order)\n    # PayPal processing logic\n  end\n\n  def process_stripe(order)\n    # Stripe processing logic\n  end\nend\n")),(0,a.kt)("p",null,"In this code, the PaymentProcessor class is responsible for processing payments for different payment types. However, if a new payment type is added (e.g. Apple Pay), the PaymentProcessor class would need to be modified to handle it. This violates the Open/Closed Principle, which states that classes should be open for extension but closed for modification.")),(0,a.kt)(s.Z,{value:"good",label:"Good",mdxType:"TabItem"},(0,a.kt)("p",null,"A better way to structure this code would be to use polymorphism to allow new payment types to be added without modifying the ",(0,a.kt)("inlineCode",{parentName:"p"},"PaymentProcessor")," class. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"class PaymentProcessor\n  def process(payment)\n    payment.process\n  end\nend\n\nclass CreditCardPayment\n  def process\n    # Credit card processing logic\n  end\nend\n\nclass PayPalPayment\n  def process\n    # PayPal processing logic\n  end\nend\n\nclass StripePayment\n  def process\n    # Stripe processing logic\n  end\nend\n")),(0,a.kt)("p",null,"With this refactored code, new payment types can be added by creating new classes that implement the process method, without modifying the PaymentProcessor class. This allows the ",(0,a.kt)("inlineCode",{parentName:"p"},"PaymentProcessor")," class to be open for extension without being modified.")),(0,a.kt)(s.Z,{value:"specs",label:"Specs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"describe PaymentProcessor do\n  describe '#process' do\n    it 'processes a credit card payment' do\n      payment = CreditCardPayment.new\n      expect(payment).to receive(:process)\n      PaymentProcessor.new.process(payment)\n    end\n\n    it 'processes a PayPal payment' do\n      payment = PayPalPayment.new\n      expect(payment).to receive(:process)\n      PaymentProcessor.new.process(payment)\n    end\n\n    it 'processes a Stripe payment' do\n      payment = StripePayment.new\n      expect(payment).to receive(:process)\n      PaymentProcessor.new.process(payment)\n    end\n  end\nend\n\ndescribe CreditCardPayment do\n  describe '#process' do\n    it 'processes the payment' do\n      payment = CreditCardPayment.new\n      expect(payment).to receive(:process)\n      payment.process\n    end\n  end\nend\n\ndescribe PayPalPayment do\n  describe '#process' do\n    it 'processes the payment' do\n      payment = PayPalPayment.new\n      expect(payment).to receive(:process)\n      payment.process\n    end\n  end\nend\n\ndescribe StripePayment do\n  describe '#process' do\n    it 'processes the payment' do\n      payment = StripePayment.new\n      expect(payment).to receive(:process)\n      payment.process\n    end\n  end\nend\n")))))}m.isMDXComponent=!0}}]);